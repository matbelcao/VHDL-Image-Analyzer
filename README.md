# VHDL-Image-Analyzer

## Description
The code implements an HW component described in VHDL, that given an image in greyscale format, calculates the area of the minimal rectangle that circumscribes
totally a figure of interest present in the image itself.The term **__'totally circumscribes'__**
is intended as the rectangle must be the smallest such that all the pixels forming the figure of interest are internal or belonging to the perimeter of the rectangle.
<br/>
The code can be successfully synthesized using **Xilinx Vivado**, has passed all the tests in "post-synthesis functional" and "post-synthesis timing", and can be implemented and passes all the tests in "post-implementation functional" and "post-implementation timing".

## Image Format
The format used to encode the image is composed of **2 parts**. The first part is the **__header__** that describes the picture's structure, while the second part describes the **__content__** of the image.
<br/>

The **__HEADER__** is composed of three fields, which are the following:
- `N_COLUMNS`: the image width (pixels)
- `N_ROWS`: the image height (pixels)
- `THRESHOLD`: the threshold value for the picture of interest
<br/>

The image **__CONTENT__** is encoded as a matrix (size `N_ROWS` x `N_COLUMNS`) in which each element of the matrix represents the grayscale value of a single pixel. Each pixel occupies a byte and can have values between 0 and 255. If the value of a pixel is greater or equal the value of `THRESHOLD`, this pixel is part of the image of interest, otherwise, it is considered a background.
<br/>

All the **__values__**, both in the header and in the image content, are **__between 0 and 255__** and are **__byte-sized__**.

## Example
The following sequence is a plaintext of a **24 x 7 image** with **threshold=6**.

<br/>
<center><img src="/img/ex1.jpg" height="250px"></img></center>
<br/>

In the memory, this image is a sequence of hexadecimal values each one is stored in a byte size. The content is stored in row order (vector of cells <0,0> <0,1> <0,2> <0,3> ... <1,0> <1,1> ... ). Whitespaces and newlines in the example are obviously not stored because the format is purely binary.

<br/>
<center><img src="/img/ex2.jpg" height="250px"></img></center>
<br/>

The **output** of the execution will be **65**, which is the area of the smallest rectangle that circumscribes the image.

## I/O Interface
The component to be developed must use the following interface to interact with the external environment (TestBench).

```
entity project_reti_logiche is
  port (
        i_clk : in std_logic;
        i_start : in std_logic;
        i_rst : in std_logic;
        i_data : in std_logic_vector(7 downto 0);
        o_address : out std_logic_vector(15 downto 0);
        o_done : out std_logic;
        o_en : out std_logic;
        o_we : out std_logic;
        o_data : out std_logic_vector (7 downto 0)
  );
end project_reti_logiche;        
```

More in detail:
- `i_clk` is the input CLOCK generated by the TestBench
- `i_start` is the START signal generated by the Test Bench
- `i_rst` is the RESET signal which initializes the machine to receive the START signal
- `i_data` is the signal (vector) that comes from the memory after a read request
- `o_address` is the output signal (vector)  that sends the address to the memory
- `o_done` is the output signal that communicates the end of the processing and that the output data has been written in memory
- `o_en` is the ENABLE signal that must be sent to the memory in order to communicate with (both in reading and writing)
- `o_we` is the WRITE ENABLE signal that must be sent to the memory (=1) in order to write. For reading must be set =0
- `o_data` is the output signal (vector) of the component towards the memory. It contains the result of the processing
